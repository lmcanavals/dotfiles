#
# Override stuff
#
setopt vi
#setopt hist_ignore_dups
setopt hist_ignore_all_dups
setopt hist_reduce_blanks

#
# Extra keymaps because home and end stopped working properly
#
bind2maps emacs             -- -s '\eOH' beginning-of-somewhere
bind2maps       viins vicmd -- -s '\eOH' vi-beginning-of-line
bind2maps emacs             -- -s '\e[H' beginning-of-somewhere
bind2maps       viins vicmd -- -s '\e[H' vi-beginning-of-line
bind2maps emacs             -- -s '\e[1~' beginning-of-somewhere
bind2maps       viins vicmd -- -s '\e[1~' vi-beginning-of-line
bind2maps emacs             -- -s '\eOF' end-of-somewhere
bind2maps       viins vicmd -- -s '\eOF' vi-end-of-line
bind2maps emacs             -- -s '\e[F' end-of-somewhere
bind2maps       viins vicmd -- -s '\e[F' vi-end-of-line
bind2maps emacs             -- -s '\e[4~' end-of-somewhere
bind2maps       viins vicmd -- -s '\e[4~' vi-end-of-line

#
# Prompt stuff
#
prompt off
autoload -U colors && colors

# /home/user/folder/stuff/tra/cool --> ~/f/s/t/cool
# cooler than %~
function cool_folder() {
	local full_path="${1:-$PWD}"
	local prefix=""
	local path_to_shorten=""

	if [[ "$full_path" == "$HOME" ]]; then
		echo "ó±‚µ "
		return 0
	elif [[ "$full_path" == "$HOME/"* ]]; then
		prefix="ó±‚µ /"
		path_to_shorten="${full_path#$HOME/}"
	elif [[ "$full_path" == "/" ]]; then
		echo "/"
		return 0
	else
		prefix="/"
		path_to_shorten="${full_path#\/}"
	fi

	if [[ -z "$path_to_shorten" ]]; then
		echo "${prefix%?}"
		return 0
	fi
	local shortened_path=$(
		echo "$path_to_shorten" | sed -e "s|\(\w\)\(\w\+\)/|\1/|g"
	)

	echo "${prefix}${shortened_path}"
}
function prompt_color() {
	local c
	[[ EUID -eq 0 ]] && c="red" || c="yellow"
	[[ $KEYMAP == vicmd ]] && c="blue"
	print "%{$fg[$c]%}"
}
function rnd_adorn() {
	local base="ğŸ¬€ğŸ¬ğŸ¬‚ğŸ¬ƒğŸ¬„ğŸ¬…ğŸ¬†ğŸ¬‡ğŸ¬ˆğŸ¬‰ğŸ¬ŠğŸ¬‹ğŸ¬ŒğŸ¬ğŸ¬ğŸ¬ğŸ¬ğŸ¬‘ğŸ¬’ğŸ¬“â–ŒğŸ¬”ğŸ¬•ğŸ¬–ğŸ¬—ğŸ¬˜ğŸ¬™ğŸ¬šğŸ¬›ğŸ¬œğŸ¬ğŸ¬ğŸ¬ŸğŸ¬ ğŸ¬¡ğŸ¬¢ğŸ¬£ğŸ¬¤ğŸ¬¥ğŸ¬¦ğŸ¬§â–ğŸ¬¨ğŸ¬©ğŸ¬ªğŸ¬«ğŸ¬¬ğŸ¬­ğŸ¬®ğŸ¬¯ğŸ¬°ğŸ¬±ğŸ¬²ğŸ¬³ğŸ¬´ğŸ¬µğŸ¬¶ğŸ¬·ğŸ¬¸ğŸ¬¹ğŸ¬ºğŸ¬»â–ˆ"
	local num_chars=${#base}
		local adorn=""
		local pos
		RANDOM=$(date +"%N")
		for i in {1..6}; do
			pos=$((RANDOM % $num_chars + 1))
			adorn+="${base[pos]}"
		done
		print "$adorn"
	}
function left_prompt() {
	local s
	[[ $KEYMAP == vicmd ]] && s=":" || s="_"
	print "$(prompt_color)$(rnd_adorn) %#$s%{$reset_color%} "
}
function right_prompt() {
	local s
	s="$(prompt_color)%n%{$fg[yellow]%}@%{$fg[cyan]%}%m:"
	s+="%{$fg[blue]%}$(cool_folder)%{$reset_color%}"
	print "$s"
}

ZLE_RPROMPT_INDENT=0 # not buggy anymore
function prompt_lmcs_setup() {
	PS2="$(prompt_color)$(rnd_adorn) %_â”Š%{$reset_color%} "
	PS3="$(prompt_color)$(rnd_adorn) ?#â”Š%{$reset_color%} "
	PS4="$(prompt_color)$(rnd_adorn) +%N:%i:%_â”Š%{$reset_color%} "

	add-zsh-hook precmd prompt_lmcs_precmd
}
function prompt_lmcs_precmd() {
	PS1="$(left_prompt)"
	if [[ $LCSTARSHIP -eq 0 ]]; then
		RPS1="$(right_prompt)"
	fi
	set_title ${(%):-"%n@%m:$(cool_folder)"}
}
function prompt_lmcs_help() {
	<<__EOF0__
	prompt lmcs

		My prompt it's super cool and uses starship to easily add stuff to the right

				- left: a simple %#_ green for users and red for root
				- right: starship stuff configured at $HOME/.config/starship.toml
__EOF0__
}
function zle-keymap-select() {
	PROMPT="$(left_prompt)"
	() { return $__prompt_status }
	zle reset-prompt
}
function zle-line-init() {
	typeset -g __prompt_status="$?"
}
zle -N zle-keymap-select
zle -N zle-line-init

prompt_themes+=( lmcs )
prompt_themes=( "${(@on)prompt_themes}" )

prompt lmcs

LCSTARSHIP=0
if command -v starship &> /dev/null; then
	eval "$(starship init zsh)"
	LCSTARSHIP=1
fi
export LCSTARSHIP

#
# Shortcuts and aliases
#
abk+=(
	"c"   " clang -std=c23 -o prog.app -g "
	"cc"  " clang++ -std=c++23 -o prog.app -g "
	"d"   " GIT_DIR=$HOME/.dotfiles.git GIT_WORK_TREE=$HOME g"
	"f"   "| fzf"
	"ga"  " git add ."
	"gc"  " git commit -a -m \"\""
	"gd"  " git difftool"
	"gp"  " git push"
	"gl"  " git pull"
	"gr"  " git restore "
	"grm" " git rm --cached "
	"gs"  " git status -u"
	"j"   "| jq -r '.[].name' "
	"n"   " nvim "
	"p"   " ps -e f"
	"qd"  " pacman -Qdt"
	"qe"  " pacman -Qet"
	"qi"  " pacman -Qi "
	"ql"  " pacman -Ql "
	"qm"  " pacman -Qm"
	"qo"  " pacman -Qo "
	"qs"  " pacman -Qs "
	"rs"  "sudo pacman -Rncs "
	"s"   "sudo pacman -S "
	"sc"  " sudo pacman -Sc"
	"si"  " pacman -Si "
	"ss"  " pacman -Ss "
	"sy"  "sudo pacman -Syu"
	"x"   "| xsel -ib"
)
bind2maps emacs viins       -- -s '^@' zleiab

alias eza="eza -F --icons --colour=auto --group-directories-first "
alias ea="eza -la "
alias eaa="eza -a .*(.)"
alias ead="eza -d .*(/)"
alias ebig="eza -l *(.OL[1,10])"
alias ee="eza -lb "
alias eed="eza -d *(/)"
alias eee="eza -d *(/^F)"
alias enew="eza -rtl *(D.om[1,10])"
alias enewdir="eza -rtdl *(/om[1,10]) .*(D/om[1,10])"
alias eold="eza -rtl *(D.Om[1,10])"
alias eolddir="eza -rtdl *(/Om[1,10]) .*(D/Om[1,10])"
alias esmall="eza -rl *(.oL[1,10])"
alias dotfiles="git --git-dir=$HOME/.dotfiles.git --work-tree=$HOME "

#
# some extra sources
#
[[ -s $ZDOTDIR/dynamic.zsh ]] && source $ZDOTDIR/dynamic.zsh
source <(fzf --zsh)

#
# various workarounds and utilities
#
_get_job_command() {
		jobs -l %% | sed -e 's/.*suspended *\(.*\)/\1/'
}
fg() {
    if [[ -n "$1" ]]; then
        local job_command=$(_get_job_command "$1")
    else
        local job_command=$(_get_job_command "%%")
    fi
    print -Pn "\e]2;$job_command \a"

    builtin fg "$@"
}

#
# plugin manager
# TODO I need to document this crap or I will forget forever
#
function lmcs-plugman() {
	local plug_gh_url
	local plug_name
	local oldpwd
	local plug_folder
	for fullname in $lmcs_plugins; do
		plug_name=$(basename $fullname)
		plug_gh_url="https://github.com/$fullname.git"
		plug_folder="$ZDOTDIR/plugins/$plug_name"
		case $@ in
			install)
				if [[ ! -d $ZDOTDIR/plugins/$plug_name ]]; then
					echo "installing $plug_name"
					git clone --depth 1 $plug_gh_url $plug_folder
				else
					echo "$plug_name is already installed, try $0 update" 
				fi
				;;
			load)
				if [[ ! -d $ZDOTDIR/plugins/$plug_name ]]; then
					echo "$plug_name not installed... installing it..."
					git clone --depth 1 $plug_gh_url $plug_folder
				fi
				source $ZDOTDIR/plugins/$plug_name/$plug_name.plugin.zsh
				;;
			update)
				if [[ -d $ZDOTDIR/plugins/$plug_name ]]; then
					echo "updating $plug_name"
					oldpwd=$(pwd)
					cd $ZDOTDIR/plugins/$plug_name
					git pull
					cd $oldpwd
				else
					echo "$plug_name not installed... installing it..."
					git clone --depth 1 $plug_gh_url $plug_folder
				fi
				;;
		esac
	done
}

lmcs_plugins=(
	zsh-users/zsh-autosuggestions
	# zsh syntax highlighting recommends loading it last
	# zsh-users/zsh-syntax-highlighting
	zdharma-continuum/fast-syntax-highlighting
)
lmcs-plugman load

# vim: set ts=2:sw=2:noet:sts=2:
